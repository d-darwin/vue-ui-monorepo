import { shallowMount } from "@vue/test-utils";
import { ROUNDING } from "@darwin-studio/vue-ui-codegen/dist/constants/rounding";
import { SIZE } from "@darwin-studio/vue-ui-codegen/dist/constants/size"; // TODO: shorter path, default export ???
import { TRANSITION } from "@darwin-studio/vue-ui-codegen/dist/constants/transition";
import codegenConfig from "@darwin-studio/vue-ui-codegen/config.json";
import prepareCssClassName from "@darwin-studio/vue-ui-codegen/src/utils/prepareCssClassName";
import DInput from "@/components/atoms/d-input";
import config from "./config";
import { baseClassCase } from "@/utils/test-case-factories";

describe("DInput", () => {
  const wrapper = shallowMount(DInput);

  baseClassCase(wrapper, config.className);

  it("Input element's value attr should contain props.value", async () => {
    const value = "external value";
    await wrapper.setProps({ value });
    const inputEl = wrapper.find("input");
    expect(inputEl.element?.value).toBe(value);
  });

  it("Should render label element with props.label content if passed", async () => {
    const label = "Some label";
    await wrapper.setProps({ label });
    const labelEl = wrapper.find("label");
    expect(labelEl.element).toBeTruthy();
    expect(labelEl.text).toBe(label);
  });

  it("Shouldn't render label element if props.label isn't passed", async () => {
    await wrapper.setProps({ label: undefined });
    const labelEl = wrapper.find("label");
    expect(labelEl.element).toBeFalsy();
  });

  // TODO: labelClass
  // TODO: labelFont
  // TODO: labelHtml

  // TODO: labelSlot???

  it("Should render passed props.id as input and label id attr", async () => {
    const id = "some-external-id";
    const label = "Some label";
    await wrapper.setProps({ id, label });
    const inputEl = wrapper.find("input");
    const labelEl = wrapper.find("label");
    expect(inputEl.attributes()?.id).toBe(id);
    expect(labelEl.attributes()?.id).toBe(id);
  });

  it("Should render equal, not null, autogenerated id attrs for the input and the label if id isn't passed", async () => {
    await wrapper.setProps({ id: undefined, label: "Some label" });

    const uuidControlId = wrapper.vm.controlId;
    const inputEl = wrapper.find("input");
    const labelEl = wrapper.find("label");

    expect(uuidControlId).toBeTruthy();
    expect(inputEl.attributes()?.id).toBe(uuidControlId);
    expect(labelEl.attributes()?.id).toBe(uuidControlId);
  });

  it("Shouldn't render id attr if there is no props.label and props.id", async () => {
    await wrapper.setProps({ id: undefined, label: undefined });
    const inputEl = wrapper.find("input");
    expect(inputEl.attributes()?.id).toBeFalsy();
  });

  // TODO: Should renders border class name ???

  // TODO: utils/test-case-factories
  it("Should renders props.rounding to rounding class", async () => {
    const rounding = ROUNDING.FULL;
    await wrapper.setProps({ rounding });
    const className = prepareCssClassName(
      codegenConfig.TOKENS.ROUNDING.CSS_CLASS_PREFIX,
      rounding
    );
    expect(wrapper.classes()).toContain(className);
  });

  // TODO: utils/test-case-factories ???
  it("Should render props.size to size class", async () => {
    const size = SIZE.HUGE;
    await wrapper.setProps({ size });
    const className = prepareCssClassName(
      codegenConfig.TOKENS.SIZE.CSS_CLASS_PREFIX,
      size
    );
    expect(wrapper.classes()).toContain(className);
  });

  // TODO: utils/test-case-factories ???
  it("Renders props.transition to transition class", async () => {
    const transition = TRANSITION.AVERAGE;
    await wrapper.setProps({ transition });
    const className = prepareCssClassName(
      codegenConfig.TOKENS.TRANSITION.CSS_CLASS_PREFIX,
      transition
    );
    expect(wrapper.classes()).toContain(className);
  });

  // TODO: error (via Tooltip ???)
  it("Should render error string (array???)", async () => {
    const error = "Some error string";
    await wrapper.setProps({ error });
    const errorEl = wrapper.find(`.${config.errorClassName}`);
    expect(errorEl.element).toBeTruthy();
    expect(errorEl.text()).toBe(error);
  });

  // TODO: errorClass
  // TODO: errorFont
  // TODO: errorHtml

  // TODO: errorSlot???

  it("Should emit onChange event", async () => {
    const wrapper = shallowMount(DInput);
    const inputEl = wrapper.find("input");
    await inputEl.trigger("change");
    expect(wrapper.emitted("change")).toBeTruthy();
  });

  // TODO: check for event's target.value

  it("Shouldn't emit onChange event if is disable", async () => {
    const wrapper = shallowMount(DInput, {
      props: { disabled: true },
    });
    const inputEl = wrapper.find("input");
    await inputEl.trigger("change");
    expect(wrapper.emitted("change")).toBeFalsy();
  });

  it("Should call passed props.whenChange", async () => {
    const whenChange = jest.fn();
    const wrapper = shallowMount(DInput, {
      props: { whenChange, disabled: false },
    });
    const inputEl = wrapper.find("input");
    await inputEl.trigger("change");
    expect(whenChange).toHaveBeenCalled();
  });

  it("Shouldn't call passed props.whenChange if is disabled", async () => {
    const whenChange = jest.fn();
    const wrapper = shallowMount(DInput, {
      props: { whenChange, disabled: true },
    });
    const inputEl = wrapper.find("input");
    await inputEl.trigger("change");
    expect(whenChange).toHaveBeenCalledTimes(0);
  });

  it("Should emit onInput event", async () => {
    const wrapper = shallowMount(DInput);
    const inputEl = wrapper.find("input");
    await inputEl.trigger("input");
    expect(wrapper.emitted("input")).toBeTruthy();
  });

  it("Shouldn't emit onInput event if is disable", async () => {
    const wrapper = shallowMount(DInput, {
      props: { disabled: true },
    });
    const inputEl = wrapper.find("input");
    await inputEl.trigger("input");
    expect(wrapper.emitted("input")).toBeFalsy();
  });

  it("Should call passed props.whenInput", async () => {
    const whenInput = jest.fn();
    const wrapper = shallowMount(DInput, {
      props: { whenInput, disabled: false },
    });
    const inputEl = wrapper.find("input");
    await inputEl.trigger("input");
    expect(whenInput).toHaveBeenCalled();
  });

  it("Shouldn't call passed props.whenInput if is disabled", async () => {
    const whenInput = jest.fn();
    const wrapper = shallowMount(DInput, {
      props: { whenInput, disabled: true },
    });
    const inputEl = wrapper.find("input");
    await inputEl.trigger("input");
    expect(whenInput).toHaveBeenCalledTimes(0);
  });

  it("Should emit onSubmit event", async () => {
    const wrapper = shallowMount(DInput);
    const inputEl = wrapper.find("input");
    await inputEl.trigger("keyup", { key: "Enter" });
    expect(wrapper.emitted("submit")).toBeTruthy();
  });

  it("Shouldn't emit onSubmit event if is disable", async () => {
    const wrapper = shallowMount(DInput, {
      props: { disabled: true },
    });
    const inputEl = wrapper.find("input");
    await inputEl.trigger("keyup", { key: "Enter" });
    expect(wrapper.emitted("submit")).toBeFalsy();
  });

  it("Should call passed props.whenSubmit", async () => {
    const whenSubmit = jest.fn();
    const wrapper = shallowMount(DInput, {
      props: { whenSubmit, disabled: false },
    });
    const inputEl = wrapper.find("input");
    await inputEl.trigger("keyup", { key: "Enter" });
    expect(whenSubmit).toHaveBeenCalled();
  });

  it("Shouldn't call passed props.whenSubmit if is disabled", async () => {
    const whenSubmit = jest.fn();
    const wrapper = shallowMount(DInput, {
      props: { whenSubmit, disabled: true },
    });
    const inputEl = wrapper.find("input");
    await inputEl.trigger("keyup", { key: "Enter" });
    expect(whenSubmit).toHaveBeenCalledTimes(0);
  });

  it("Should should render before slot", () => {
    const slotBeforeClass = "slotBefore";
    const slotBefore = <div class={slotBeforeClass}>before slot content</div>;
    shallowMount(DInput, {
      slots: {
        before: slotBefore,
      },
    });
    const slotBeforeEl = wrapper.find(`.${slotBeforeClass}`);
    expect(slotBeforeEl.element).toBeTruthy();
  });

  it("Should should render after slot", () => {
    const slotAfterClass = "slotAfter";
    const slotAfter = <div class={slotAfterClass}>after slot content</div>;
    shallowMount(DInput, {
      slots: {
        after: slotAfter,
      },
    });
    const slotAfterEl = wrapper.find(`.${slotAfterClass}`);
    expect(slotAfterEl.element).toBeTruthy();
  });

  // TODO: prevent default ???

  // TODO: min/max width ???
});
