import { mount } from "@vue/test-utils";
import {
  baseClassCase,
  colorSchemeClassCase,
  controlIdAbsenceCase,
  controlIdAutogeneratedCase,
  controlIdPresenceCase,
  elementValueAttrCase,
  fontSizeClassCase,
  minControlWidthCase,
  offsetCase,
  propStringCase,
  propVNodeCase,
  roundingClassCase,
  sizeClassCase,
  slotCase,
  tagCase,
  transitionClassCase,
} from "@/utils/test-case-factories";
import DProgress from "@/components/atoms/d-progress";
import { DCaptionAsync } from "@/components/atoms/d-caption/async";
import DCaption from "@/components/atoms/d-caption";
import DLoader from "@/components/atoms/d-loader";
import config from "@/components/atoms/d-progress/config";
import { Type } from "@/components/atoms/d-progress/types";
import sleep from "@/utils/sleep";
import { COLOR_SCHEME } from "@darwin-studio/ui-codegen/dist/constants/color-scheme";
import { ROUNDING } from "@darwin-studio/ui-codegen/dist/constants/rounding";
import { SIZE } from "@darwin-studio/ui-codegen/dist/constants/size";
import { TRANSITION } from "@darwin-studio/ui-codegen/dist/constants/transition";

describe("DProgress", () => {
  const wrapper = mount(DProgress);

  baseClassCase(wrapper, config.className);

  controlIdAbsenceCase(wrapper, `.${config.progressClassName}`);
  controlIdPresenceCase(wrapper, `.${config.progressClassName}`);
  controlIdAutogeneratedCase(wrapper, `.${config.progressClassName}`);

  propStringCase(wrapper, `.${config.labelClassName}`, "label");
  propVNodeCase(wrapper, `.${config.labelClassName}`, "label");
  slotCase(DProgress, `.${config.labelClassName}`, "label");
  offsetCase(wrapper, `.${config.labelClassName}`, "labelOffset");
  // TODO: props.labelOptions

  elementValueAttrCase(wrapper, 34, `.${config.progressClassName}`);

  it("Should render linear variant if props.type === Type.linear", async () => {
    await wrapper.setProps({
      type: Type.linear,
      value: 99,
    });
    const progressEl = wrapper.find(`.${config.progressClassName}`);
    expect(progressEl.classes()).toContain(config.linearClassName);
  });

  it("Should render circular variant if props.type === Type.linear", async () => {
    await wrapper.setProps({
      type: Type.circular,
      value: 99,
    });
    const progressEl = wrapper.find(`.${config.progressClassName}`);
    expect(progressEl.classes()).toContain(config.circularClassName);
  });

  it("Should render linear progress content as '${props.value}%'", async () => {
    const value = 19;
    await wrapper.setProps({
      type: Type.linear,
      value,
    });

    const progressEl = wrapper.find(`.${config.progressClassName}`);
    expect(progressEl.text()).toBe(`${value}%`);
  });
  // TODO: props.progressOptions

  propStringCase(wrapper, `.${config.contentClassName}`, "content");
  propVNodeCase(wrapper, `.${config.contentClassName}`, "content");
  slotCase(DProgress, `.${config.contentClassName}`, "default", {
    value: 12,
  });
  // TODO: props.contentOptions

  it(`Should render props.caption as string`, async () => {
    const caption = "some text content";
    await wrapper.setProps({ caption, value: 56 });
    await sleep(0); // Should wait next event loop step for asyncComponent to be imported

    const captionComp = wrapper.findComponent(DCaptionAsync);
    expect(captionComp?.html()).toMatch(caption);
  });

  propVNodeCase(wrapper, `.${config.captionClassName}`, "caption");
  slotCase(DProgress, `.${config.captionClassName}`, "caption");
  offsetCase(wrapper, `.${config.captionClassName}`, "captionOffset");
  // TODO: props.captionOptions

  colorSchemeClassCase(
    wrapper,
    `.${config.progressClassName}`,
    COLOR_SCHEME.ALTERNATIVE,
    { value: 11 }
  );

  it(`Should pass props.colorScheme to the DLoader`, async () => {
    const colorScheme = COLOR_SCHEME.SECONDARY;
    await wrapper.setProps({ colorScheme, value: undefined });
    await sleep(0); // Should wait next event loop step for asyncComponent to be imported

    const loaderComp = wrapper.findComponent(DLoader);
    expect(loaderComp?.props().colorScheme).toBe(colorScheme);
  });

  colorSchemeClassCase(
    wrapper,
    `.${config.contentClassName}`,
    COLOR_SCHEME.DANGER,
    { value: 11 }
  );

  roundingClassCase(wrapper, `.${config.progressClassName}`, {
    value: 99,
  });

  it(`Should pass props.rounding to the DLoader`, async () => {
    const rounding = ROUNDING.SMALL;
    await wrapper.setProps({
      value: undefined,
      rounding,
      loaderOptions: { rounding },
    });
    await sleep(0); // Should wait next event loop step for asyncComponent to be imported

    const loaderComp = wrapper.findComponent(DLoader);
    expect(loaderComp?.props().rounding).toBe(rounding);
  });

  roundingClassCase(wrapper, `.${config.contentClassName}`, {
    type: Type.circular,
    value: 99,
    content: "Not empty",
  });

  fontSizeClassCase(wrapper, `.${config.className}`);

  sizeClassCase(wrapper, `.${config.className}`);

  it(`Should pass props.size as size and font to the DLoader`, async () => {
    const size = SIZE.SMALL;
    await wrapper.setProps({
      value: undefined,
      size,
      loaderOptions: { size },
    });
    await sleep(0); // Should wait next event loop step for asyncComponent to be imported

    const loaderComp = wrapper.findComponent(DLoader);
    expect(loaderComp?.props().size).toBe(size);
    expect(loaderComp?.props().font).toBe(size);
  });

  it(`Should pass props.size font to DCaption`, async () => {
    const size = SIZE.SMALL;
    await wrapper.setProps({
      value: 78,
      size,
      caption: "Not empty",
      captionOptions: { size },
    });
    await sleep(0); // Should wait next event loop step for asyncComponent to be imported

    const captionComp = wrapper.findComponent(DCaption);
    expect(captionComp?.props().font).toBe(size);
  });

  minControlWidthCase(wrapper, `.${config.linearClassName}`, {
    type: Type.linear,
    value: 99,
  });

  transitionClassCase(wrapper, `.${config.progressClassName}`, {
    value: 32,
  });

  it(`Should render props.transition to DLoader classes`, async () => {
    const transition = TRANSITION.AVERAGE;
    await wrapper.setProps({ transition, value: undefined });
    await sleep(0); // Should wait next event loop step for asyncComponent to be imported

    const loaderComp = wrapper.findComponent(DLoader);
    expect(loaderComp?.props().transition).toBe(transition);
  });

  transitionClassCase(wrapper, `.${config.captionClassName}`, {
    value: 81,
    caption: "Not empty",
  });

  tagCase(wrapper);

  propStringCase(wrapper, `.${config.loaderContainerClassName}`, "loader", {
    value: undefined,
  });

  propVNodeCase(wrapper, `.${config.loaderContainerClassName}`, "loader", {
    value: undefined,
  });

  slotCase(DProgress, `.${config.loaderContainerClassName}`, "loader", {
    value: undefined,
  });
  // TODO: props.loaderOptions

  // TODO: indeterminate -> branches

  // TODO: aria attrs
});
