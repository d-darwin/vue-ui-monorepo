import { mount, shallowMount } from "@vue/test-utils";
import DSlider from "@darwin-studio/vue-ui/src/components/atoms/d-slider";
import DCaption from "@darwin-studio/vue-ui/src/components/atoms/d-caption";
import { COLOR_SCHEME } from "@darwin-studio/ui-codegen/dist/constants/color-scheme";
import { SIZE } from "@darwin-studio/ui-codegen/dist/constants/size";
import {
  baseClassCase,
  colorSchemeClassCase,
  controlIdAbsenceCase,
  controlIdAutogeneratedCase,
  controlIdPresenceCase,
  disabledAttrCase,
  fontSizeClassCase,
  elementValueAttrCase,
  labelAbsenceCase,
  propStringCase,
  propVNodeCase,
  minControlWidthCase,
  outlineClassCase,
  roundingClassCase,
  sizeClassCase,
  slotCase,
  tagCase,
  transitionClassCase,
  offsetCase,
} from "@/utils/test-case-factories";
import config from "./config";

describe("DSlider", () => {
  const wrapper = mount(DSlider);

  baseClassCase(wrapper, config.className);

  controlIdAbsenceCase(wrapper);

  controlIdPresenceCase(wrapper);

  controlIdAutogeneratedCase(wrapper);

  elementValueAttrCase(wrapper, 33);

  // TODO: attr case factory
  it("Should render props.min to the input's min attr", async () => {
    const min = 13;
    await wrapper.setProps({ min });

    const inputEl = wrapper.find(`.${config.inputClassName}`);
    expect(inputEl.attributes().min).toBe(String(min));
  });

  it("Should render props.max to the input's max attr", async () => {
    const max = 66;
    await wrapper.setProps({ max });

    const inputEl = wrapper.find(`.${config.inputClassName}`);
    expect(inputEl.attributes().max).toBe(String(max));
  });

  it("Should render props.step to the input's step attr", async () => {
    const step = 4;
    await wrapper.setProps({ step });

    const inputEl = wrapper.find(`.${config.inputClassName}`);
    expect(inputEl.attributes().step).toBe(String(step));
  });

  labelAbsenceCase(wrapper);
  propStringCase(wrapper, `.${config.labelClassName}`, "label");
  propVNodeCase(wrapper, `.${config.labelClassName}`, "label");
  slotCase(DSlider, `.${config.labelClassName}`, "label");

  offsetCase(wrapper);

  colorSchemeClassCase(
    wrapper,
    `.${config.trackClassName}`,
    COLOR_SCHEME.DANGER
  );

  slotCase(DSlider, `.${config.trackClassName}`, "track");

  it("Shouldn't render caption element if props.caption isn't passed", async () => {
    await wrapper.setProps({ caption: undefined });
    const captionEl = wrapper.find(`.${config.captionClassName}`);
    expect(captionEl.exists()).toBeFalsy();
    await wrapper.setProps({ caption: "not empty" });
  });

  it("Should render caption element with props.caption content if passed", async () => {
    const captionContent = "some caption";
    const caption = <div>{captionContent}</div>;
    await wrapper.setProps({ caption });

    const captionEl = wrapper.find(`.${config.captionClassName}`);
    expect(captionEl.exists()).toBeTruthy();
    expect(captionEl.text()).toBe(captionContent);
  });

  slotCase(DSlider, `.${config.captionClassName}`, "caption");

  it("Should render props.captionOffset to the caption style as '--offset: props.captionOffset'", async () => {
    const captionOffset = 33;
    await wrapper.setProps({
      caption: "Caption string",
      captionOffset,
    });

    const captionEl = wrapper.find(`.${config.captionClassName}`);
    expect(captionEl.attributes("style")).toContain(
      `--offset: ${captionOffset}`
    );
  });

  colorSchemeClassCase(
    wrapper,
    `.${config.inputClassName}`,
    COLOR_SCHEME.DANGER
  );

  outlineClassCase(
    wrapper,
    `.${config.inputClassName}`,
    COLOR_SCHEME.DANGER,
    SIZE.SMALL
  );

  roundingClassCase(wrapper, `.${config.trackClassName}`);

  roundingClassCase(wrapper, `.${config.inputClassName}`);

  sizeClassCase(wrapper, `.${config.className}`);

  fontSizeClassCase(wrapper, `.${config.labelClassName}`);

  minControlWidthCase(wrapper);

  transitionClassCase(wrapper, `.${config.captionClassName}`);

  disabledAttrCase(wrapper, `.${config.inputClassName}`);

  tagCase(wrapper);

  it("Should emit onChange event with value payload", async () => {
    const value = 34;
    const newValue = 99;
    const wrapper = shallowMount(DSlider, { props: { value } });
    const inputEl = wrapper.find("input");

    await inputEl.setValue(newValue);
    await inputEl.trigger("change");

    expect(wrapper.emitted("change")?.[0]).toStrictEqual([String(newValue)]);
    expect(wrapper.emitted("update:value")?.[0]).toStrictEqual([
      String(newValue),
    ]);
  });

  it("Shouldn't emit onChange if props.disabled is passed", async () => {
    const value = 34;
    const disabled = true;
    const wrapper = shallowMount(DSlider, {
      props: { value, disabled },
    });

    const inputEl = wrapper.find("input");
    const newValue = 99;
    await inputEl.setValue(newValue);
    await inputEl.trigger("change");

    expect(wrapper.emitted("change")?.[0]).toBeFalsy();
    expect(wrapper.emitted("update:value")?.[0]).toBeFalsy();
  });

  it("Should call passed props.whenChange", async () => {
    const value = 33;
    const whenChange = jest.fn();
    const wrapper = mount(DSlider, {
      props: { value, whenChange },
    });

    const inputEl = wrapper.find("input");
    const newValue = 99;
    await inputEl.setValue(newValue);
    await inputEl.trigger("change");

    expect(whenChange).toHaveBeenCalledWith(String(newValue));
  });

  it("Shouldn't call passed props.whenChange if props.disabled passed", async () => {
    const value = 33;
    const disabled = true;
    const whenChange = jest.fn();
    const wrapper = mount(DSlider, {
      props: { value, disabled, whenChange },
    });

    const inputEl = wrapper.find("input");
    await inputEl.trigger("change");

    expect(whenChange).toHaveBeenCalledTimes(0);
  });

  it("Should emit onInput event with value payload", async () => {
    const value = 34;
    const newValue = 99;
    const wrapper = shallowMount(DSlider, { props: { value } });
    const inputEl = wrapper.find("input");

    await inputEl.setValue(newValue);
    await inputEl.trigger("input");

    expect(wrapper.emitted("input")?.[0]).toStrictEqual([String(newValue)]);
    expect(wrapper.emitted("update:value")?.[0]).toStrictEqual([
      String(newValue),
    ]);
  });

  it("Shouldn't emit onInput if props.disabled is passed", async () => {
    const value = 34;
    const disabled = true;
    const wrapper = shallowMount(DSlider, {
      props: { value, disabled },
    });

    const inputEl = wrapper.find("input");
    const newValue = 99;
    await inputEl.setValue(newValue);
    await inputEl.trigger("input");

    expect(wrapper.emitted("input")?.[0]).toBeFalsy();
    expect(wrapper.emitted("update:value")?.[0]).toBeFalsy();
  });

  it("Should call passed props.whenInput", async () => {
    const value = 33;
    const whenInput = jest.fn();
    const wrapper = mount(DSlider, {
      props: { value, whenInput },
    });

    const inputEl = wrapper.find("input");
    const newValue = 99;
    await inputEl.setValue(newValue);
    await inputEl.trigger("input");

    expect(whenInput).toHaveBeenCalledWith(String(newValue));
  });

  it("Shouldn't call passed props.whenInput if props.disabled passed", async () => {
    const value = 33;
    const disabled = true;
    const whenInput = jest.fn();
    const wrapper = mount(DSlider, {
      props: { value, disabled, whenInput },
    });

    const inputEl = wrapper.find("input");
    await inputEl.trigger("input");

    expect(whenInput).toHaveBeenCalledTimes(0);
  });

  it("Should merge props from props.track and TRACK_DEFAULTS to the track element attrs", async () => {
    const externalClass = "some-external-class";
    const wrapper = mount(DSlider);
    await wrapper.setProps({
      trackOptions: {
        class: externalClass,
      },
    });

    const trackEl = wrapper.find(`.${config.trackClassName}`);
    expect(trackEl.classes()).toContain(externalClass);
  });

  it("Should merge props from props.input and INPUT_DEFAULTS to the input element attrs", async () => {
    const externalClass = "some-external-class";
    const wrapper = mount(DSlider);
    await wrapper.setProps({
      inputOptions: {
        class: externalClass,
      },
    });

    const inputEl = wrapper.find(`.${config.inputClassName}`);
    expect(inputEl.classes()).toContain(externalClass);
  });

  it("Should merge props from props.label and LABEL_DEFAULTS to the label element attrs", async () => {
    const externalClass = "some-external-class";
    const wrapper = mount(DSlider);
    await wrapper.setProps({
      label: "not empty",
      labelOptions: {
        class: externalClass,
      },
    });

    const labelEl = wrapper.find(`.${config.labelClassName}`);
    expect(labelEl.classes()).toContain(externalClass);
  });

  it("Should merge props from props.caption and CAPTION_DEFAULTS to the caption element attrs", async () => {
    const externalClass = "some-external-class";
    const wrapper = mount(DSlider, {
      props: {
        caption: "not empty",
        captionOptions: {
          class: externalClass,
        },
      },
    });

    const caption = wrapper.findComponent(DCaption);
    expect(caption.classes()).toContain(externalClass);
  });
});
